<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Minimal Task Timer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      // Tailwind CSS Configuration
      tailwind.config = {
        theme: {
          extend: {
            // Custom color palette for dark theme
            colors: {
              "dark-bg": "#111827",           // Main page background
              "dark-card": "#1F2937",         // Card/container background
              "dark-card-hover": "#374151",   // Background for interactive elements like task items
              "dark-text": "#E5E7EB",         // Primary text color
              "dark-text-light": "#9CA3AF",   // Secondary/muted text color
              "dark-accent": "#ff58af",       // Main accent color (timer, progress bar, highlights)
              "dark-border": "#374151",       // Border color for elements
              "dark-progress-bg": "#374151",  // Background of the progress bar track
              "accent-indigo": "#ff58af",     // Category 1 border/accent
              "accent-emerald": "#6EE7B7",   // Category 2 border/accent
              "accent-amber": "#FBBF24",     // Category 3 border/accent
              "accent-rose": "#3bb5ff",       // Category 4 border/accent
              "stop-red": "#F87171",         // Stop button background
              "stop-red-hover": "#EF4444",     // Stop button background on hover
            },
            // Custom monospace font stack
            fontFamily: {
              mono: ['"Source Code Pro"', "monospace"],
            },
            // Custom border radius values for specific elements
            borderRadius: {
              "task-item": "0.375rem", // Specific radius for individual task items
              "category-col": "0.5rem", // Specific radius for category columns/cards
            },
          },
        },
      };
    </script>
    <!-- Google Fonts: Source Code Pro (weights 400 for regular, 600 for semi-bold) -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      /* Base body styles: Apply custom font and enable smooth scrolling */
      body {
        font-family: "Source Code Pro", monospace;
        scroll-behavior: smooth;
      }

      /* Custom scrollbar styling for WebKit browsers (Chrome, Safari, Edge) */
      ::-webkit-scrollbar {
        width: 8px; /* Width of the scrollbar */
      }
      ::-webkit-scrollbar-track {
        background: #1f2937; /* Background color of the scrollbar track */
      }
      ::-webkit-scrollbar-thumb {
        background: #4b5563; /* Color of the scrollbar handle (thumb) */
        border-radius: 4px; /* Rounded corners for the thumb */
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #6b7280; /* Color of the thumb on hover */
      }

      /* Style for text elements overlaid on the progress bar */
      .progress-bar-text {
        color: #e5e7eb; /* Ensure text is readable on the progress bar */
      }

      /* Animation: Simple fade-in effect */
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      .fade-in {
        opacity: 0; /* Start hidden */
        animation: fadeIn 0.5s ease-in-out forwards; /* Apply animation */
      }

      /* Animation: Slide up slightly and fade-in */
      @keyframes slideUpFadeIn {
        from {
          opacity: 0;
          transform: translateY(10px); /* Start slightly lower */
        }
        to {
          opacity: 1;
          transform: translateY(0); /* End at original position */
        }
      }
      .slide-up-fade-in {
        opacity: 0; /* Start hidden */
        animation: slideUpFadeIn 0.4s ease-out forwards; /* Apply animation */
      }

      /* Apply staggered animation delay to category columns for a cascading effect */
      .category-column:nth-child(1) { animation-delay: 0.1s; }
      .category-column:nth-child(2) { animation-delay: 0.2s; }
      .category-column:nth-child(3) { animation-delay: 0.3s; }
      .category-column:nth-child(4) { animation-delay: 0.4s; }

      /* Style individual task items with transitions for hover effects */
      .task-item {
        transition: background-color 0.2s ease-in-out,
          transform 0.15s ease-in-out, /* Smooth transform on hover */
          box-shadow 0.2s ease-in-out;
      }
      .task-item:hover {
        transform: translateY(-2px); /* Subtle lift effect on hover */
      }

      /* Style for the currently active task item (using Tailwind @apply for ring utility) */
      .task-item-active {
        /* Apply a ring to visually indicate the active task */
        @apply ring-2 ring-dark-accent ring-offset-2 ring-offset-dark-card;
      }
    </style>
  </head>
  <body
    class="bg-dark-bg text-dark-text min-h-screen font-mono pb-32 antialiased" /* Ensure enough padding at bottom for fixed timer */
  >
    <div class="container mx-auto px-4 py-8">
      <!-- Header Section -->
      <header class="mb-10 text-center fade-in">
        <h1 class="text-4xl font-semibold text-dark-accent">Hello!</h1>
        <p class="text-xl text-dark-text-light mt-2" id="date-display">
          Loading date...
        </p>
      </header>

      <!-- Task Categories Grid -->
      <div
        class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6"
        id="categories-container"
      >
        <!-- Category columns and task items will be dynamically inserted here by JavaScript -->
      </div>

      <!-- Task JSON Editor Section -->
      <div
        class="mt-12 bg-dark-card p-4 rounded-lg border border-dark-border fade-in"
        style="animation-delay: 0.5s" /* Slightly later fade-in */
      >
        <h2 class="text-lg font-semibold mb-3">Edit Tasks (JSON)</h2>
        <textarea
          id="tasks-json-editor"
          class="w-full h-40 bg-dark-card-hover border border-dark-border rounded p-3 text-dark-text font-mono text-sm focus:outline-none focus:ring-2 focus:ring-dark-accent resize-y"
          placeholder="Paste or edit your task data in JSON format here..."
        ></textarea>
        <div class="mt-2 flex justify-end">
          <button
            id="save-tasks-button"
            class="bg-dark-accent hover:bg-opacity-80 text-white px-4 py-2 rounded-md text-sm font-semibold transition-colors duration-200"
          >
            Save Tasks
          </button>
        </div>
      </div>
    </div>

    <!-- Fixed Persistent Timer UI -->
    <!-- Initially hidden (opacity-0, translate-y-full), controlled by JS -->
    <div
      id="timer-ui"
      class="fixed bottom-0 left-0 right-0 bg-dark-card border-t border-dark-border p-3 opacity-0 pointer-events-none z-50 transition-all duration-500 ease-in-out transform translate-y-full"
    >
      <div class="container mx-auto"> <!-- Container for layout within the fixed bar -->

        <!-- Status Message Display (Top of the timer UI) -->
        <div
          id="status-message"
          class="text-sm text-dark-text-light text-center mb-2 w-full" /* Center text, add bottom margin */
        >
          Select a task to begin. <!-- Default message -->
        </div>

        <!-- Flex container for Timer, Progress Bar, and Stop Button -->
        <div class="flex items-center justify-between gap-x-4 gap-y-2 flex-wrap"> <!-- Allow wrapping on small screens -->

          <!-- Timer Display & Stop Button Group -->
          <div class="flex items-center gap-3 flex-shrink-0"> <!-- Prevent shrinking too much -->
            <span
              id="timer-display"
              class="text-3xl font-semibold text-dark-accent w-24 text-center tabular-nums" /* Fixed width, monospace numbers */
              >00:00</span
            >
            <button
              id="stop-button"
              class="bg-stop-red hover:bg-stop-red-hover text-white px-3 py-1 rounded-md text-xs font-semibold tracking-wider transition-colors duration-200"
            >
              STOP
            </button>
          </div>

          <!-- Progress Bar Area -->
          <div class="w-full sm:flex-1 min-w-[200px]"> <!-- Take remaining space on larger screens, ensure min width -->
            <div
              class="relative bg-dark-progress-bg h-5 rounded-full overflow-hidden flex items-center px-2" /* Container for progress */
            >
              <!-- Inner progress bar element (width controlled by JS) -->
              <div
                id="progress-bar-inner"
                class="absolute top-0 left-0 bg-dark-accent h-full rounded-full z-0 transition-[width] duration-500 ease-linear" /* Smooth width transition */
                style="width: 0%"
              ></div>
              <!-- Text overlay container on the progress bar -->
              <div class="relative z-10 w-full flex justify-between items-center">
                <!-- "Ahead of others" message (left side) -->
                <span
                  id="ahead-message"
                  class="text-xs font-medium progress-bar-text truncate pr-2 opacity-0 transition-opacity duration-300 ease-in-out" /* Initially hidden, fades in */
                ></span>
                <!-- Percentage display (right side) -->
                <span
                  id="progress-percentage"
                  class="text-xs font-semibold progress-bar-text flex-shrink-0" /* Prevent shrinking */
                  >0%</span
                >
              </div>
            </div>
          </div>

          <!-- Old Status Message Position (REMOVED - Moved to the top) -->

        </div>
      </div>
    </div>

    <script>
      // ==================================
      // Minimal Task Timer Script
      // ==================================

      // --- Configuration & Constants ---

      // Maps category keys (used in task data) to display names.
      const CATEGORY_MAPPING = {
        1: "Studies & Learning",
        2: "Creative & Fun",
        3: "Improvement & Care",
        4: "Projects & Work",
      };
      // Maps category keys to Tailwind border color classes for the category columns.
      const CATEGORY_BORDER_COLORS = {
        1: "border-accent-indigo",
        2: "border-accent-emerald",
        3: "border-accent-amber",
        4: "border-accent-rose",
      };
      // Array of Tailwind classes used to highlight the active task item. Stored as a constant for easy application/removal.
      const ACTIVE_TASK_CLASSES = ['ring-2', 'ring-dark-accent', 'ring-offset-2', 'ring-offset-dark-card'];

      // --- Default Task Data ---
      // Initial data used if nothing is found in local storage.
      // Structure: { "Task Name": { category_key: number, streak: number, last_top_percentage: float, total_time: seconds, customTimerMinutes?: number } }
      let tasksData = {
        "Deep Work Session": { category_key: 1, streak: 5, last_top_percentage: 88.0, total_time: 15000, customTimerMinutes: 45 },
        "Code Practice": { category_key: 1, streak: 0, last_top_percentage: 0, total_time: 3600 },
        "Creative Writing": { category_key: 2, streak: 3, last_top_percentage: 75.5, total_time: 7200 },
        "Quick Sketch": { category_key: 2, streak: 0, last_top_percentage: 0, total_time: 0, customTimerMinutes: 15 },
        "Meditation": { category_key: 3, streak: 10, last_top_percentage: 99.0, total_time: 5000, customTimerMinutes: 10 },
        "Exercise": { category_key: 3, streak: 0, last_top_percentage: 0, total_time: 9000 },
        "Project Planning": { category_key: 4, streak: 1, last_top_percentage: 95.2, total_time: 9000 },
        "Admin & Emails": { category_key: 4, streak: 0, last_top_percentage: 0, total_time: 0 }
      };

      // --- DOM Element References ---
      // Cache frequently accessed DOM elements for performance.
      const timerUI = document.getElementById("timer-ui");
      const timerDisplay = document.getElementById("timer-display");
      const progressBarInner = document.getElementById("progress-bar-inner");
      const stopButton = document.getElementById("stop-button");
      const statusMessage = document.getElementById("status-message");
      const aheadMessage = document.getElementById("ahead-message");
      const progressPercentageText = document.getElementById("progress-percentage");
      const dateDisplay = document.getElementById("date-display");
      const categoriesContainer = document.getElementById("categories-container");
      const tasksJsonEditor = document.getElementById("tasks-json-editor");
      const saveTasksButton = document.getElementById("save-tasks-button");

      // --- Timer State & Variables ---
      let timerInterval = null;        // Holds the interval ID for the timer, null when stopped.
      let totalSeconds = 0;            // Total duration of the current timer phase (warmup, work, break).
      let currentSeconds = 0;          // Remaining seconds in the current timer phase.
      let timerPhase = "idle";         // Current phase: "idle", "warmup", "work", "break".
      let currentTaskName = "";        // Name of the task currently being timed (or the task associated with the break).
      let notificationPermission = Notification.permission; // Stores the browser notification permission status.
      let aheadPercentage = 70;        // Simulated percentage for the "ahead of others" display.
      const populationEstimate = 500000; // Arbitrary number for the "ahead of others" calculation.
      // Messages displayed periodically during work/warmup phases.
      const encouragementMessages = [ "Keep the momentum!", "Focus mode: ON", "You're doing great!", "Making progress!", "Stay sharp!", "One step closer.", "Consistency yields results.", "Almost there!", "Excellent focus!", "Keep pushing!" ];
      let lastEncouragementIndex = -1; // Tracks the last used encouragement message index to avoid repeats.
      let messageUpdateCounter = 0;    // Counter used to time encouragement message updates.
      // Default durations (in seconds) for timer phases if not specified by task.
      const DEFAULT_WARMUP_DURATION = 60;    // 1 minute
      const DEFAULT_WORK_DURATION = 24 * 60; // 24 minutes
      const DEFAULT_BREAK_DURATION = 5 * 60;  // 5 minutes

      // --- Helper Functions ---

      /**
       * Formats a total number of seconds into MM:SS format.
       * @param {number} seconds - The total seconds to format.
       * @returns {string} The formatted time string (e.g., "05:30").
       */
      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60).toString().padStart(2, "0");
        const secs = (seconds % 60).toString().padStart(2, "0");
        return `${mins}:${secs}`;
      }

      /**
       * Formats a large number into a compact representation (e.g., 1.2M, 500k).
       * @param {number} num - The number to format.
       * @returns {string} The formatted number string.
       */
      function formatNumber(num) {
        if (num >= 1000000) return (num / 1000000).toFixed(1) + "M";
        if (num >= 1000) return (num / 1000).toFixed(0) + "k";
        return num.toString();
      }

      /**
       * Formats a total number of seconds into a human-readable duration string (e.g., "1h 30m", "45m", "30s").
       * @param {number} seconds - The total seconds to format.
       * @returns {string} The formatted duration string.
       */
      function formatTotalTime(seconds) {
        if (!seconds || seconds <= 0) return "0s"; // Handle null, undefined, 0 or negative seconds
        if (seconds < 60) return `${seconds}s`;    // Less than a minute
        if (seconds < 3600) return `${Math.floor(seconds / 60)}m`; // Less than an hour
        // Hours and minutes
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        if (minutes === 0) return `${hours}h`; // Whole hours
        return `${hours}h ${minutes}m`;        // Hours and minutes
      }

      // --- Task Highlighting Functions ---

      /** Removes the active highlight classes from all task items. */
      function clearActiveTaskHighlight() {
          const allTaskItems = categoriesContainer.querySelectorAll('.task-item');
          allTaskItems.forEach(item => {
              // Use spread syntax with remove to handle multiple classes easily
              item.classList.remove(...ACTIVE_TASK_CLASSES);
          });
      }

      /**
       * Clears any existing highlight and applies highlight classes to the specified task item.
       * Uses a data attribute selector for robustness.
       * @param {string} taskName - The name of the task whose item should be highlighted.
       */
      function setActiveTaskHighlight(taskName) {
          clearActiveTaskHighlight(); // Ensure only one task is highlighted
          if (taskName) {
              // Use CSS.escape to handle potential special characters in task names safely
              const taskItem = categoriesContainer.querySelector(`.task-item[data-task-name="${CSS.escape(taskName)}"]`);
              if (taskItem) {
                  taskItem.classList.add(...ACTIVE_TASK_CLASSES); // Apply the highlight classes
              } else {
                  // Log a warning if the element wasn't found (e.g., after JSON edit removed the task)
                  console.warn(`Could not find task item element for highlighting: ${taskName}`);
              }
          }
      }


      // --- UI Update Functions ---

      /** Updates the timer display (MM:SS) and the browser window title. */
      function updateTimerDisplay() {
        timerDisplay.textContent = formatTime(currentSeconds);
        // Update window title only when a timer is active
        if (timerPhase !== "idle") {
          document.title = `${formatTime(currentSeconds)} - ${currentTaskName} | Focus Timer`;
        } else {
          document.title = "Minimal Task Timer"; // Reset title when idle
        }
      }

      /** Updates the progress bar width, percentage text, and the "ahead of others" message. */
      function updateProgressBarAndMessages() {
        let percentage = 0;
        // Calculate percentage completed (avoid division by zero)
        if (totalSeconds > 0) {
          percentage = ((totalSeconds - currentSeconds) / totalSeconds) * 100;
        }
        // Clamp percentage between 0 and 100 and round
        const displayPercentage = Math.max(0, Math.min(100, Math.round(percentage)));
        // Set the width of the inner progress bar element
        progressBarInner.style.width = `${displayPercentage}%`;
        // Update the percentage text display
        progressPercentageText.textContent = `${displayPercentage}%`;

        // Update the "ahead" message only during work/warmup phases
        if ((timerPhase === "work" || timerPhase === "warmup") && totalSeconds > 0) {
          // Simulate a gradually increasing percentage (just for visual flair)
          aheadPercentage = Math.min(99.8, aheadPercentage + Math.random() * 0.05);
          // Calculate the estimated number of people "behind"
          const aheadCount = Math.floor(populationEstimate * (1 - aheadPercentage / 100));
          aheadMessage.textContent = `${aheadPercentage.toFixed(1)}% (~${formatNumber(aheadCount)})`;
          // Fade in the message
          aheadMessage.style.opacity = 1;
        } else {
          // Fade out the message when not in work/warmup
          aheadMessage.style.opacity = 0;
          // Clear text after fade out transition (300ms)
          setTimeout(() => {
            if (aheadMessage.style.opacity === "0") aheadMessage.textContent = "";
          }, 300);
        }
      }

      /**
       * Updates the status message displayed in the timer UI.
       * @param {string} [message=null] - A specific message to display. If null, generates based on phase.
       * @param {boolean} [isEncouragement=false] - If true and message is null, displays a random encouragement message (during work/warmup).
       */
      function updateStatusMessage(message = null, isEncouragement = false) {
        let newMessage = "";
        if (message) {
          // Use provided message directly
          newMessage = message;
        } else if (isEncouragement && (timerPhase === "work" || timerPhase === "warmup")) {
          // Select a random encouragement message, avoiding immediate repetition
          let randomIndex;
          do {
             randomIndex = Math.floor(Math.random() * encouragementMessages.length);
          } while (randomIndex === lastEncouragementIndex && encouragementMessages.length > 1);
          lastEncouragementIndex = randomIndex;
          newMessage = encouragementMessages[randomIndex];
        } else if (timerPhase === "work") {
          newMessage = `Focus: ${currentTaskName}`;
        } else if (timerPhase === "warmup") {
          newMessage = `Warmup: ${currentTaskName}`;
        } else if (timerPhase === "break") {
          newMessage = `Break Time! Relax...`;
        } else {
          // Default idle message
          newMessage = "Select a task.";
        }
        statusMessage.textContent = newMessage;
      }

      // --- Web Notification Logic ---

      /** Requests permission to show browser notifications if not already granted or denied. */
      function requestNotificationPermission() {
        // Only request if permission is currently undetermined ('default')
        if (notificationPermission === "default") {
          Notification.requestPermission().then((permission) => {
            notificationPermission = permission; // Update stored permission status
            // Optionally, notify the user if permission was granted
            if (permission === "granted") {
              new Notification("Notifications Enabled!", {
                body: "You will now receive timer alerts.",
                silent: true, // Make this notification silent
                tag: "permission-status", // Use a tag to prevent multiple permission notifications
              });
            }
          });
        }
      }

      /**
       * Shows a browser notification if permission is granted and the window is not focused.
       * @param {string} title - The title of the notification.
       * @param {string} body - The body text of the notification.
       */
      function showNotification(title, body) {
        // Only show if permission is granted
        if (notificationPermission === "granted") {
          const notificationTag = "task-timer-alert"; // Tag to replace previous timer notifications
          // Show notification only if the document/tab is not currently visible/active
          if (document.hidden) {
            new Notification(title, { body: body, tag: notificationTag, silent: false }); // Non-silent alert
          }
        }
      }

      // --- Timer Core Logic ---

      /**
       * Stops the current timer, clears the interval, and resets the state.
       * @param {boolean} [resetPhase=true] - If true, resets phase to 'idle', hides timer UI, and clears highlight. If false, only stops the interval and resets seconds (used after break).
       */
      function stopTimer(resetPhase = true) {
        clearInterval(timerInterval); // Stop the interval
        timerInterval = null;
        clearActiveTaskHighlight();   // Always remove highlight when stopping completely or after break

        if (resetPhase) {
          timerPhase = "idle";
          // Hide the timer UI smoothly
          timerUI.style.opacity = 0;
          timerUI.style.pointerEvents = "none";
          timerUI.style.transform = "translateY(100%)";
          updateStatusMessage("Select a task."); // Reset status message
          currentTaskName = ""; // Clear the current task context
        }
        // If resetPhase is false (e.g., after a break), we keep the timer UI visible
        // and potentially keep currentTaskName for context, but the timer itself is stopped.

        // Reset timer seconds regardless of resetPhase
        currentSeconds = 0;
        totalSeconds = 0;
        updateTimerDisplay();
        updateProgressBarAndMessages(); // Update UI to reflect stopped state (00:00, 0%)
      }


      /**
       * Starts a new timer phase (warmup, work, or break) for a given task.
       * Handles UI updates, state changes, and interval creation.
       * @param {string} taskName - The name of the task to associate with the timer.
       * @param {"warmup" | "work" | "break"} phase - The phase to start.
       */
      function startTimer(taskName, phase) {
        requestNotificationPermission(); // Ensure permission is requested if needed
        clearInterval(timerInterval); // Clear any existing timer interval first

        // --- Update State & UI ---
        setActiveTaskHighlight(taskName); // Highlight the newly selected task item

        // Make the timer UI visible and interactive
        timerUI.style.opacity = 1;
        timerUI.style.pointerEvents = "auto";
        timerUI.style.transform = "translateY(0)";

        // Set timer state variables *before* duration calculation
        currentTaskName = taskName; // Update the globally tracked task name
        timerPhase = phase;
        aheadPercentage = 70 + Math.random() * 10; // Reset ahead percentage with some variance
        messageUpdateCounter = 0; // Reset encouragement message counter

        let initialMessage = "";
        let durationToUse = 0;

        // --- Determine Duration and Initial Message ---
        if (phase === "warmup") {
          durationToUse = DEFAULT_WARMUP_DURATION;
          initialMessage = `Warmup: ${currentTaskName}...`;
        } else if (phase === "work") {
          const taskSettings = tasksData[currentTaskName]; // Get settings for the current task
          // Use custom timer if defined and valid, otherwise use default
          if (taskSettings && typeof taskSettings.customTimerMinutes === 'number' && taskSettings.customTimerMinutes > 0) {
             durationToUse = taskSettings.customTimerMinutes * 60; // Convert minutes to seconds
          } else {
             durationToUse = DEFAULT_WORK_DURATION;
          }
          initialMessage = `Focus: ${currentTaskName}...`;
        } else if (phase === "break") {
          durationToUse = DEFAULT_BREAK_DURATION;
          initialMessage = `Break Time! Relax...`;
        } else {
          // Fallback for invalid phase - should not happen normally
          console.error("Invalid timer phase:", phase);
          stopTimer(); // Stop completely if phase is invalid
          return;
        }

        // Set the total and current seconds for the timer
        totalSeconds = durationToUse;
        currentSeconds = totalSeconds;

        // Update UI elements immediately
        updateTimerDisplay();
        updateProgressBarAndMessages();
        updateStatusMessage(initialMessage); // Set the initial status message

        // --- Start the Interval ---
        timerInterval = setInterval(() => {
          currentSeconds--; // Decrement remaining seconds
          messageUpdateCounter++; // Increment counter for encouragement messages

          // Update timer and progress bar displays every second
          updateTimerDisplay();
          updateProgressBarAndMessages();

          // Show encouragement message periodically during work phase (e.g., every 45 seconds)
          if (timerPhase === "work" && currentSeconds > 0 && messageUpdateCounter >= 45) {
            updateStatusMessage(null, true); // Show random encouragement
            messageUpdateCounter = 0; // Reset counter
          }

          // Check if the timer has reached zero
          if (currentSeconds <= 0) {
            clearInterval(timerInterval); // Stop the interval
            handleTimerCompletion(); // Handle the completion of the current phase
          }
        }, 1000); // Run every 1000ms (1 second)
      }

      /** Handles the logic when a timer phase (warmup, work, break) completes. */
      function handleTimerCompletion() {
        let notificationTitle = "";
        let notificationBody = "";
        let completionMessage = "";
        const completedDuration = totalSeconds; // Store duration before it's reset

        if (timerPhase === "warmup") {
          // --- Warmup Complete ---
          notificationTitle = "Warm-up Done!";
          notificationBody = `Starting ${currentTaskName} focus.`;
          completionMessage = `Starting focus: ${currentTaskName}`;
          showNotification(notificationTitle, notificationBody); // Send browser notification
          updateStatusMessage(completionMessage);
          // Automatically transition to the 'work' phase for the same task
          // Highlight remains as we move directly to the work phase
          startTimer(currentTaskName, "work");

        } else if (timerPhase === "work") {
          // --- Work Complete ---
          // Update task stats if the task still exists in our data
          if (tasksData[currentTaskName]) {
            tasksData[currentTaskName].streak = (tasksData[currentTaskName].streak || 0) + 1; // Increment streak
            tasksData[currentTaskName].last_top_percentage = parseFloat(aheadPercentage.toFixed(1)); // Record performance metric
            tasksData[currentTaskName].total_time = (tasksData[currentTaskName].total_time || 0) + completedDuration; // Add elapsed time
            saveTasksToLocalStorage(); // Persist changes
            renderCategories(); // Refresh the UI to show updated stats (streak, total time)
            // Re-apply highlight after rendering, as renderCategories rebuilds the DOM elements.
            // This is handled within renderCategories now.
          }

          notificationTitle = "Focus Complete!";
          notificationBody = `Nice work on ${currentTaskName}! Break time.`;
          completionMessage = `Completed ${currentTaskName}! Take a break.`;
          showNotification(notificationTitle, notificationBody);
          updateStatusMessage(completionMessage);
          // Automatically transition to the 'break' phase, keeping the task context and highlight
          startTimer(currentTaskName, "break");

        } else if (timerPhase === "break") {
          // --- Break Complete ---
          notificationTitle = "Break Over!";
          notificationBody = `Ready for the next task?`;
          completionMessage = "Break's over! Select next task.";
          showNotification(notificationTitle, notificationBody);
          // Stop the timer mechanism, but keep the UI visible and clear the highlight.
          // `stopTimer(false)` stops the interval but leaves UI visible.
          stopTimer(false);
          // Explicitly clear highlight after break completion
          clearActiveTaskHighlight();
          // Ensure UI stays visible (stopTimer(false) doesn't hide it, but good practice)
          timerUI.style.opacity = 1;
          timerUI.style.pointerEvents = "auto";
          timerUI.style.transform = "translateY(0)";
          updateStatusMessage(completionMessage);
          // The timer is now stopped, waiting for the user to select a new task.
          // currentTaskName remains from the break for context until a new task is started.
        }
      }


      // --- Data Storage Functions ---

      /** Loads task data from localStorage, parses it, and updates the editor. */
      function loadTasksFromLocalStorage() {
        const savedTasks = localStorage.getItem("tasksData"); // Get raw data string
        if (savedTasks) {
          try {
            const parsedData = JSON.parse(savedTasks); // Attempt to parse JSON
            // Basic validation: ensure it's a non-null object
            if (typeof parsedData === 'object' && parsedData !== null) {
                tasksData = parsedData; // Update in-memory data
            } else {
                console.warn("Saved tasks data from localStorage is not a valid object. Using defaults.");
                // Optionally provide user feedback or stick with defaults
            }
          } catch (e) {
            // Handle JSON parsing errors
            console.error("Error parsing tasks data from localStorage:", e);
            alert("Error loading saved tasks. Data might be corrupted. Using default tasks.");
            // tasksData remains the default data defined earlier
          }
        }
        // Update the JSON editor field with the current (loaded or default) data, formatted nicely
        tasksJsonEditor.value = JSON.stringify(tasksData, null, 2); // Use 2 spaces for indentation
      }

      /** Saves the current `tasksData` object to localStorage and updates the editor. */
      function saveTasksToLocalStorage() {
        try {
          // Convert the tasksData object to a JSON string
          const tasksJsonString = JSON.stringify(tasksData);
          // Save the string to localStorage
          localStorage.setItem("tasksData", tasksJsonString);
          // Update the editor field to reflect the saved data (or user edits if saved from editor)
          tasksJsonEditor.value = JSON.stringify(tasksData, null, 2);
        } catch (e) {
          // Handle potential errors during stringification or saving (e.g., storage quota exceeded)
          console.error("Error saving tasks data to localStorage:", e);
          alert("Could not save tasks. Check browser storage limits or console for errors.");
        }
      }

      // --- UI Rendering Functions ---

      /** Renders the category columns and task items based on the current `tasksData`. */
      function renderCategories() {
        const previouslyActiveTask = currentTaskName; // Remember which task was active before re-rendering
        categoriesContainer.innerHTML = ""; // Clear existing category columns and tasks

        // Group tasks by their category key
        const tasksByCategory = {};
        // Initialize empty arrays for each defined category
        for (const key in CATEGORY_MAPPING) {
            tasksByCategory[key] = [];
        }

        // Populate the category groups with task details
        for (const [taskName, details] of Object.entries(tasksData)) {
          const categoryKey = details.category_key;
          // Check if the category key is valid and exists in our mapping
          if (tasksByCategory[categoryKey]) {
            tasksByCategory[categoryKey].push({
              name: taskName,
              streak: details.streak || 0, // Default to 0 if missing
              last_top_percentage: details.last_top_percentage || 0, // Default to 0
              total_time: details.total_time || 0, // Default to 0
              customTimerMinutes: details.customTimerMinutes // Keep undefined if missing
            });
          } else {
            // Log a warning for tasks with invalid category keys
            console.warn(`Task "${taskName}" has an invalid or unmapped category key: ${categoryKey}`);
          }
        }

        // Iterate through each defined category and create its column
        for (const categoryKey in CATEGORY_MAPPING) {
          const categoryName = CATEGORY_MAPPING[categoryKey];
          const borderColorClass = CATEGORY_BORDER_COLORS[categoryKey] || "border-dark-border"; // Fallback border
          const tasks = tasksByCategory[categoryKey]; // Get tasks for this category

          // Create the main div for the category column
          const categoryColumn = document.createElement("div");
          // Apply base styles, border color, layout, and animation
          categoryColumn.className = `category-column bg-dark-card rounded-category-col border-t-4 ${borderColorClass} flex flex-col min-h-[250px] slide-up-fade-in`;

          // Create the header div for the category name
          const categoryHeader = document.createElement("div");
          categoryHeader.className = "p-4 border-b border-dark-border flex-shrink-0"; // Styling and bottom border
          categoryHeader.innerHTML = `<h2 class="text-lg font-semibold text-dark-text text-center tracking-wide">${categoryName}</h2>`;
          categoryColumn.appendChild(categoryHeader);

          // Create the container for task items within the column
          const tasksContainer = document.createElement("div");
          // Allow vertical scrolling if tasks overflow, provide spacing
          tasksContainer.className = "p-4 space-y-3 overflow-y-auto flex-grow";

          if (tasks.length > 0) {
            // Sort tasks alphabetically by name within the category
            tasks.sort((a, b) => a.name.localeCompare(b.name));

            // Create and append each task item
            tasks.forEach((task) => {
              const taskItem = document.createElement("div");
              // Apply base styles, hover effects, and set data attribute for identification
              taskItem.className = "task-item bg-dark-card-hover p-3 rounded-task-item hover:bg-opacity-80 cursor-pointer border border-dark-border transition-all duration-150";
              taskItem.setAttribute("data-task-name", task.name);

              // **Crucially**: Add the active highlight classes *during rendering* if this task
              // matches the one that was active before the render, and the timer isn't idle.
              if (task.name === previouslyActiveTask && timerPhase !== 'idle') {
                   taskItem.classList.add(...ACTIVE_TASK_CLASSES);
              }

              // Construct the inner HTML for the task item (name, stats)
              let taskInfoHTML = `
                <div class="flex justify-between items-center">
                    <span class="font-semibold text-base text-dark-text block truncate pr-2">${task.name}</span>`; // Task name (truncated if long)
              // Display streak only if it's greater than 0
              if (task.streak > 0) {
                taskInfoHTML += `<span class="text-sm text-amber-400 font-medium flex items-center gap-0.5 ml-2 flex-shrink-0" title="Current Streak: ${task.streak}"><span class="text-base">ðŸ”¥</span><span>${task.streak}</span></span>`; // Streak icon and count
              }
              taskInfoHTML += `</div>`;
              // Display last performance and total time tracked
              taskInfoHTML += `<div class="mt-1 flex justify-between text-xs text-dark-text-light">`;
              taskInfoHTML += `<span title="Last Session Performance">Last: Top ${task.last_top_percentage.toFixed(1)}%</span>`; // Last performance metric
              taskInfoHTML += `<span title="Total Time Tracked">${formatTotalTime(task.total_time)}</span>`; // Formatted total time
              taskInfoHTML += `</div>`;

              taskItem.innerHTML = taskInfoHTML; // Set the generated HTML
              tasksContainer.appendChild(taskItem); // Add the task item to its container

              // Add click listener to each task item to start the timer
              taskItem.addEventListener("click", () => {
                const taskNameToStart = taskItem.getAttribute("data-task-name");
                // Prevent restarting if the *same* task is clicked while running (and not on break)
                if (timerPhase !== 'idle' && currentTaskName === taskNameToStart && timerPhase !== 'break') {
                    console.log(`Task "${taskNameToStart}" is already running.`);
                    return; // Do nothing
                }
                // Start the timer flow (warmup -> work -> break) for the clicked task
                // startTimer handles stopping any previous timer and setting the highlight.
                startTimer(taskNameToStart, "warmup");
              });
            });
          } else {
            // Display a message if the category has no tasks
            tasksContainer.innerHTML = `<p class="text-sm text-center text-dark-text-light italic mt-6 px-2">No tasks in this category.</p>`;
          }

          categoryColumn.appendChild(tasksContainer); // Add tasks container to the column
          categoriesContainer.appendChild(categoryColumn); // Add the completed column to the main grid
        }
        // Note: The active task highlight is now applied directly within the loop above,
        // making a separate call to setActiveTaskHighlight after rendering unnecessary and potentially less reliable.
      }


      // --- Event Listeners ---

      // Listener for the main STOP button in the timer UI
      stopButton.addEventListener("click", () => {
        const stoppedTask = currentTaskName; // Remember task name before stopping
        const stoppedPhase = timerPhase;     // Remember phase
        stopTimer(); // Perform a full stop and reset (hides UI, clears highlight, sets phase to idle)
        // Provide feedback if a timer was actually running (not idle or just finished break)
        if (stoppedPhase !== "idle" && stoppedPhase !== "break") {
          updateStatusMessage(`Stopped ${stoppedTask}. Select task.`);
        }
      });

      // Listener for the 'Save Tasks' button below the JSON editor
      saveTasksButton.addEventListener("click", () => {
        try {
          const editorContent = tasksJsonEditor.value;
          // Basic validation: Don't save if the editor is empty or whitespace only
          if (!editorContent.trim()) {
            alert("Cannot save empty task data. Please add task details in JSON format.");
            return;
          }
          // Attempt to parse the JSON content from the editor
          const newTasksData = JSON.parse(editorContent);
          // More validation: Ensure the parsed data is a non-null object
          if (typeof newTasksData !== 'object' || newTasksData === null) {
            throw new Error("Invalid JSON structure: Root must be an object {}.");
          }

          // Check if a timer was running *before* we potentially modify data and stop it
          const wasRunning = timerInterval !== null;
          const taskBeforeSave = currentTaskName; // Remember the task name if timer was running

          // Update the in-memory tasksData with the parsed data
          tasksData = newTasksData;
          saveTasksToLocalStorage(); // Persist the new data immediately

          // If a timer was running, stop it *before* re-rendering the UI
          // This prevents issues if the running task was modified or removed in the JSON
          if (wasRunning) {
              stopTimer(); // Full stop: clears interval, resets state, hides UI, clears highlight
          }

          renderCategories(); // Re-render the categories and tasks with the new data

          // Set an appropriate status message after rendering
          if (wasRunning) {
              // If timer was stopped due to save, inform the user
              updateStatusMessage(`Tasks updated (${taskBeforeSave} stopped). Select task.`);
          } else {
               // If timer wasn't running, just confirm save
               updateStatusMessage("Tasks saved successfully. Select a task.");
          }
           alert("Tasks saved successfully!"); // Provide confirmation feedback

        } catch (e) {
          // Handle JSON parsing errors or other issues during save
          console.error("Error saving tasks from JSON editor:", e);
          alert("Error saving tasks: Invalid JSON format.\n\nPlease check your JSON syntax.\n\nDetails: " + e.message);
        }
      });

      // --- Initialization ---

      /** Sets up the application on page load. */
      function initialize() {
        // Display the current date in the header
        const now = new Date();
        const options = { weekday: "long", year: "numeric", month: "long", day: "numeric" };
        dateDisplay.textContent = `Today is ${now.toLocaleDateString("en-US", options)}`;

        // Load task data from storage (or use defaults)
        loadTasksFromLocalStorage();
        // Render the initial UI based on the loaded data
        renderCategories();

        // Set initial state for timer display and progress bar (00:00, 0%)
        updateTimerDisplay();
        updateProgressBarAndMessages();
        // Ensure no task is highlighted initially
        clearActiveTaskHighlight();
        // Initial status message is set inside stopTimer/updateStatusMessage logic
      }

      // --- Run Initialization ---
      // Execute the initialize function once the script is loaded
      initialize();
    </script>
  </body>
</html>
